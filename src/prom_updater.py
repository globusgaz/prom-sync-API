# src/prom_updater.py
import asyncio
import json
import os
import random
import csv
from typing import Dict, List, Any
import aiohttp

from src.config import get_settings
from src.feed_parser import load_urls, fetch_all_offers
from src.prom_client import PromClient
from src.change_detector import detect_changes, persist_state


def chunked(items: List[Dict], size: int) -> List[List[Dict]]:
    return [items[i:i + size] for i in range(0, len(items), size)]


def extract_updates_from_offers(offers_xml: List[str]) -> List[Dict]:
    """–í–∏—Ç—è–≥—É—î–º–æ –∑ XML –æ—Ñ—Ñ–µ—Ä—ñ–≤ vendorCode, price, quantity"""
    import re

    vc_re = re.compile(r"<vendorCode>([^<]+)</vendorCode>")
    price_re = re.compile(r"<price>([^<]+)</price>")
    qty_re = re.compile(
        r"<(?:quantity|stock_quantity|count|quantity_in_stock)>([^<]+)</(?:quantity|stock_quantity|count|quantity_in_stock)>"
    )
    avail_re = re.compile(
        r"<offer[^>]*?available=\"(true|1|yes|available|in_stock|false|0|no|out_of_stock)\"",
        re.IGNORECASE,
    )

    updates: List[Dict] = []
    for xml in offers_xml:
        vendor_code = None
        m = vc_re.search(xml)
        if m:
            vendor_code = m.group(1).strip()
        if not vendor_code:
            continue

        price = None
        mp = price_re.search(xml)
        if mp:
            try:
                price = float(mp.group(1).strip().replace(",", "."))
            except Exception:
                price = None

        quantity = None
        mq = qty_re.search(xml)
        if mq:
            try:
                quantity = int(float(mq.group(1).strip()))
            except Exception:
                quantity = None
        else:
            ma = avail_re.search(xml)
            if ma:
                quantity = 1 if ma.group(1).lower() in (
                    "true", "1", "yes", "available", "in_stock"
                ) else 0

        update: Dict = {"vendor_code": vendor_code}
        if price is not None:
            update["price"] = price
        if quantity is not None:
            update["quantity"] = quantity
        updates.append(update)
    return updates


def extract_products_from_response(data: Any) -> List[Dict]:
    """–ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ Prom –¥–æ —Å–ø–∏—Å–∫—É —Ç–æ–≤–∞—Ä—ñ–≤"""
    if not data:
        return []
    if isinstance(data, dict):
        # –Ω–∞–π—á–∞—Å—Ç—ñ—à–µ Prom API –ø–æ–≤–µ—Ä—Ç–∞—î {"products": [...], "total_count": N}
        for k in ("products", "items", "data", "result"):
            if k in data and isinstance(data[k], list):
                return data[k]
    if isinstance(data, list):
        return data
    return []


async def build_vendor_to_id_map(client: PromClient, session: aiohttp.ClientSession, debug: bool = False) -> Dict[str, int]:
    vendor_to_id: Dict[str, int] = {}
    page = 1
    per_page = 100

    while True:
        status, data = await client.get_products(session, page=page, per_page=per_page)
        if status != 200:
            print(f"‚ö†Ô∏è –ü–æ–º–∏–ª–∫–∞ {status} –Ω–∞ —Å—Ç–æ—Ä—ñ–Ω—Ü—ñ {page}")
            break

        products = extract_products_from_response(data)

        if page == 1 and debug:
            print("DEBUG: /products/list raw keys:", list(data.keys()) if isinstance(data, dict) else type(data))
            if products:
                try:
                    print("DEBUG: –ø—Ä–∏–∫–ª–∞–¥ –ø—Ä–æ–¥—É–∫—Ç—É:", json.dumps(products[0], ensure_ascii=False)[:1000])
                except Exception:
                    pass

        if not products:
            break

        for p in products:
            ext = p.get("external_id") or p.get("vendor_code") or p.get("sku")
            pid = p.get("id")
            if ext and pid:
                vendor_to_id[str(ext).strip()] = int(pid)

        total = data.get("total_count") if isinstance(data, dict) else None
        if total and page * per_page >= int(total):
            break
        page += 1

    if debug:
        print(f"DEBUG: –º–∞–ø–∞ vendor->id —Ä–æ–∑–º—ñ—Ä = {len(vendor_to_id)}")

    return vendor_to_id


async def main_async() -> int:
    settings = get_settings()

    urls = load_urls(os.path.join(os.getcwd(), "feeds.txt"))
    print(f"üîó –ó–Ω–∞–π–¥–µ–Ω–æ {len(urls)} –ø–æ—Å–∏–ª–∞–Ω—å —É feeds.txt")
    if not urls:
        return 0

    changed, new_state = await detect_changes(urls)
    print(f"üß≠ –ó–º—ñ–Ω–∏ —É —Ñ—ñ–¥–∞—Ö: {'—Ç–∞–∫' if changed else '–Ω—ñ'}")
    if not changed and not settings.dry_run:
        print("‚è≠Ô∏è –ó–º—ñ–Ω –Ω–µ –≤–∏—è–≤–ª–µ–Ω–æ ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞—î–º–æ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è")
        return 0

    all_offers, _ = await fetch_all_offers(urls)
    print(f"üì¶ –ó–∞–≥–∞–ª—å–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Ç–æ–≤–∞—Ä—ñ–≤: {len(all_offers)}")

    updates = extract_updates_from_offers(all_offers)

    client = PromClient(
        base_url=settings.prom_base_url,
        token=settings.prom_api_token,
        auth_header=settings.prom_auth_header,
        auth_scheme=settings.prom_auth_scheme,
        timeout_seconds=settings.http_timeout_seconds,
    )

    async with aiohttp.ClientSession() as session:
        vendor_to_id = await build_vendor_to_id_map(client, session, debug=True)
        print(f"üìä –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ {len(vendor_to_id)} –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—Å—Ç–µ–π vendorCode ‚Üí id")

        converted = []
        for u in updates:
            vc = u["vendor_code"]
            pid = vendor_to_id.get(vc)
            if not pid:
                continue
            obj = {"id": pid}
            if "price" in u:
                obj["price"] = u["price"]
            if "quantity" in u:
                obj["quantity_in_stock"] = u["quantity"]
                obj["presence"] = "available" if u["quantity"] > 0 else "not_available"
            converted.append(obj)

        print(f"üõ†Ô∏è –ì–æ—Ç–æ–≤–æ {len(converted)} –æ–Ω–æ–≤–ª–µ–Ω—å (–Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ vendor_code: {len(updates) - len(converted)})")

        if not converted:
            print("üö´ –ù–µ–º–∞—î –æ–Ω–æ–≤–ª–µ–Ω—å –¥–ª—è –≤—ñ–¥–ø—Ä–∞–≤–∫–∏")
            return 0

        batches = chunked(converted, settings.batch_size)
        print(f"üöö –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ {len(batches)} –ø–∞—Ä—Ç—ñ–π")
        sent = 0
        for idx, batch in enumerate(batches, start=1):
            status, text = await client.update_products(session, "/api/v1/products/edit_by_external_id", batch)
            ok = 200 <= status < 300
            print(f"[{idx}/{len(batches)}] HTTP {status} ‚Äî {'OK' if ok else 'ERROR'}; items={len(batch)}")
            if not ok or os.getenv("DEBUG_PROM") == "1":
                print("–í—ñ–¥–ø–æ–≤—ñ–¥—å Prom:", text[:1000])
            if ok:
                sent += len(batch)

        persist_state(new_state)
        print(f"‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ. –û–Ω–æ–≤–ª–µ–Ω–æ –∑–∞–ø–∏—Å—ñ–≤: {sent}")

    return 0


if __name__ == "__main__":
    raise SystemExit(asyncio.run(main_async()))
