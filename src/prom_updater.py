import os
import json
import xml.etree.ElementTree as ET
import time
import asyncio
import aiohttp
from hashlib import md5
from typing import Tuple, Optional, Dict, Any, List

API_URL = "https://my.prom.ua/api/v1/products/edit_by_external_id"
API_TOKEN = os.getenv("PROM_API_TOKEN")

FEEDS_FILE = "feeds.txt"
STATE_FILE = "product_state.json"

# –ü—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å
BATCH_SIZE = 100
CONCURRENT_REQUESTS = 3
REQUEST_TIMEOUT_FEED = 180
REQUEST_TIMEOUT_API = 120
DELAY_BETWEEN_WAVES = 0.3

# –í–∏–º–æ–≥–∞ —Ü—ñ–ª—ñ—Å–Ω–æ—Å—Ç—ñ
REQUIRE_ALL_FEEDS = True  # —è–∫—â–æ —Ö–æ—á –æ–¥–∏–Ω —Ñ—ñ–¥ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π ‚Äî –∑—É–ø–∏–Ω—è—î–º–æ—Å—å, —â–æ–± –Ω–µ –∑—ñ–ø—Å—É–≤–∞—Ç–∏ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å

# HTTP –∑–∞–≥–æ–ª–æ–≤–∫–∏ (–Ω—ñ–∂–Ω—ñ –¥–æ –±–ª–æ–∫—É–≤–∞–Ω—å)
HEADERS = {
    "User-Agent": (
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
        "AppleWebKit/537.36 (KHTML, like Gecko) "
        "Chrome/117.0.0.0 Safari/537.36"
    )
}

def load_previous_state() -> Dict[str, Dict[str, Any]]:
    if os.path.exists(STATE_FILE):
        try:
            with open(STATE_FILE, "r") as f:
                return json.load(f)
        except Exception:
            return {}
    return {}

def save_current_state(products: List[Dict[str, Any]]) -> None:
    state = {}
    for p in products:
        state[p["id"]] = {
            "price": p.get("price"),
            "presence": p.get("presence"),
            "quantity_in_stock": p.get("quantity_in_stock")
        }
    with open(STATE_FILE, "w") as f:
        json.dump(state, f, indent=2)

def has_changed(product: Dict[str, Any], old_state: Dict[str, Dict[str, Any]]) -> bool:
    pid = product["id"]
    if pid not in old_state:
        return True
    old = old_state[pid]
    return (
        old.get("price") != product.get("price") or
        old.get("presence") != product.get("presence") or
        old.get("quantity_in_stock") != product.get("quantity_in_stock")
    )

def _get_text(el: ET.Element, tag: str) -> Optional[str]:
    node = el.find(tag)
    return node.text.strip() if node is not None and node.text else None

def _safe_float(text: Optional[str]) -> Optional[float]:
    if not text:
        return None
    try:
        return float(text.replace(",", ".").strip())
    except Exception:
        return None

def _infer_availability(offer: ET.Element) -> Tuple[Optional[str], Optional[int], bool]:
    """
    –ü–æ–≤–µ—Ä—Ç–∞—î (presence, quantity_in_stock, sure_flag).
    - presence ‚àà {"available","not_available"} –∞–±–æ None
    - quantity_in_stock ‚àà int –∞–±–æ None
    - sure_flag: —á–∏ –≤–ø–µ–≤–Ω–µ–Ω–æ –º–æ–∂–µ–º–æ –æ–Ω–æ–≤–ª—é–≤–∞—Ç–∏ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å (presence_sure)
    –õ–æ–≥—ñ–∫–∞ –æ–±–µ—Ä–µ–∂–Ω–∞: —è–∫—â–æ –Ω–µ–º–∞—î —á—ñ—Ç–∫–∏—Ö —Å–∏–≥–Ω–∞–ª—ñ–≤ - –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ (None, None, False).
    """
    # 1) –°–∏–ª—å–Ω–∏–π —Å–∏–≥–Ω–∞–ª: –∞—Ç—Ä–∏–±—É—Ç available
    avail_attr = offer.get("available")
    if avail_attr is not None:
        v = avail_attr.strip().lower()
        if v in {"true", "1", "yes", "available", "in_stock"}:
            return "available", 1, True
        if v in {"false", "0", "no", "not_available", "out_of_stock"}:
            return "not_available", 0, True

    # 2) –°–∏–ª—å–Ω–∏–π —Å–∏–≥–Ω–∞–ª: –∫—ñ–ª—å–∫—ñ—Å–Ω–∏–π —Ç–µ–≥
    for tag in ["quantity", "stock_quantity", "count", "quantity_in_stock", "g:quantity"]:
        node = offer.find(tag)
        if node is not None and node.text:
            q = _safe_float(node.text)
            if q is not None:
                q_int = max(0, int(q))
                return ("available" if q_int > 0 else "not_available", q_int, True)

    # 3) –°–µ—Ä–µ–¥–Ω—ñ–π —Å–∏–≥–Ω–∞–ª: —Ç–µ–∫—Å—Ç–æ–≤—ñ –ø–æ–ª—è
    for tag in ["availability", "instock", "in_stock", "g:availability"]:
        node = offer.find(tag)
        if node is not None and node.text:
            txt = node.text.strip().lower()
            if txt in {"true", "1", "in stock", "available", "yes", "instock"}:
                return "available", 1, True
            if txt in {"false", "0", "out of stock", "unavailable", "no"}:
                return "not_available", 0, True

    # 4) –ù–µ–º–∞—î –≤–ø–µ–≤–Ω–µ–Ω–æ—Å—Ç—ñ ‚Äî –Ω–µ —á—ñ–ø–∞—î–º–æ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å
    return None, None, False

def _build_external_id(offer: ET.Element, feed_index: int) -> str:
    offer_id = offer.get("id") or ""
    vendor_code = _get_text(offer, "vendorCode")
    base = (vendor_code or offer_id or md5(ET.tostring(offer)).hexdigest()).strip()
    return f"f{feed_index}_{base}"

def _extract_price(offer: ET.Element) -> Optional[float]:
    # –ù–∞–π—á–∞—Å—Ç—ñ—à—ñ –≤–∞—Ä—ñ–∞–Ω—Ç–∏
    price_text = None
    price_node = offer.find("price")
    if price_node is not None and price_node.text:
        price_text = price_node.text
    if not price_text:
        # —ñ–Ω—à—ñ –∫–∞—Å—Ç–æ–º–Ω—ñ –ø–æ–ª—è (–¥–æ–ø–æ–≤–Ω—é–π—Ç–µ –∑–∞ –ø–æ—Ç—Ä–µ–±–∏)
        for tag in ["g:price", "current_price"]:
            node = offer.find(tag)
            if node is not None and node.text:
                price_text = node.text
                break
    return _safe_float(price_text) if price_text else None

async def parse_feed(session: aiohttp.ClientSession, url: str, feed_index: int) -> Tuple[bool, List[Dict[str, Any]]]:
    try:
        async with session.get(url, headers=HEADERS, timeout=REQUEST_TIMEOUT_FEED) as response:
            if response.status != 200:
                print(f"‚ùå {url} ‚Äî HTTP {response.status}")
                return False, []
            content = await response.read()
            root = ET.fromstring(content)
            offers = root.findall(".//offer")
            products: List[Dict[str, Any]] = []

            for offer in offers:
                external_id = _build_external_id(offer, feed_index)
                price = _extract_price(offer)

                presence, qty, sure = _infer_availability(offer)

                item: Dict[str, Any] = {"id": external_id}
                if price is not None:
                    item["price"] = price

                # –ö—Ä–∏—Ç–∏—á–Ω–æ: –æ–Ω–æ–≤–ª—é—î–º–æ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –º–∏ –≤–ø–µ–≤–Ω–µ–Ω—ñ
                if sure:
                    item["presence"] = presence
                    item["quantity_in_stock"] = qty
                    item["_presence_sure"] = True
                else:
                    # –ù–Ü–Ø–ö–ò–• presence/quantity ‚Äî –Ω–µ —á—ñ–ø–∞—î–º–æ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å
                    item["_presence_sure"] = False

                products.append(item)

            return True, products
    except Exception as e:
        print(f"‚ùå {url}: {e}")
        return False, []

async def send_updates(session: aiohttp.ClientSession, batch: List[Dict[str, Any]], batch_num: int, total_batches: int) -> None:
    headers = {
        "Authorization": f"Bearer {API_TOKEN}",
        "Content-Type": "application/json",
        "X-LANGUAGE": "uk"
    }

    payload: List[Dict[str, Any]] = []
    for item in batch:
        obj = {"id": item["id"]}
        # –¶—ñ–Ω–∞ –∑–∞–≤–∂–¥–∏, —è–∫—â–æ —î
        if item.get("price") is not None:
            obj["price"] = item["price"]
        # –ù–∞—è–≤–Ω—ñ—Å—Ç—å ‚Äî —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –≤–ø–µ–≤–Ω–µ–Ω—ñ
        if item.get("_presence_sure"):
            obj["presence"] = item.get("presence")
            obj["presence_sure"] = True
            obj["quantity_in_stock"] = item.get("quantity_in_stock")
        payload.append(obj)

    print(f"üîÑ –ü–∞—Ä—Ç—ñ—è {batch_num}/{total_batches} ({len(payload)} —Ç–æ–≤–∞—Ä—ñ–≤)")

    try:
        async with session.post(API_URL, headers=headers, json=payload, timeout=REQUEST_TIMEOUT_API) as response:
            response_text = await response.text()
            if response.status == 200:
                try:
                    result = json.loads(response_text)
                    processed = len(result.get("processed_ids", []))
                    errors = result.get("errors", {})
                    if errors:
                        print(f"‚ö†Ô∏è –ü–∞—Ä—Ç—ñ—è {batch_num}: –æ–±—Ä–æ–±–ª–µ–Ω–æ {processed}/{len(payload)}, –ø–æ–º–∏–ª–æ–∫: {len(errors)}")
                        for i, (ext_id, error) in enumerate(list(errors.items())[:5]):
                            print(f"  ‚ùå {ext_id}: {error}")
                    else:
                        print(f"‚úÖ –ü–∞—Ä—Ç—ñ—è {batch_num}: {processed}/{len(payload)}")
                    if batch_num == 1:
                        print(f"üìã –í—ñ–¥–ø–æ–≤—ñ–¥—å API: {json.dumps(result, ensure_ascii=False, indent=2)[:500]}")
                except json.JSONDecodeError:
                    print(f"‚ùå –ü–∞—Ä—Ç—ñ—è {batch_num} - –Ω–µ JSON –≤—ñ–¥–ø–æ–≤—ñ–¥—å: {response_text[:200]}")
            else:
                print(f"‚ùå –ü–∞—Ä—Ç—ñ—è {batch_num} - HTTP {response.status}: {response_text[:200]}")
    except Exception as e:
        print(f"‚ùå –ü–∞—Ä—Ç—ñ—è {batch_num}: {e}")

async def main_async() -> None:
    if not API_TOKEN:
        print("‚ùå –¢–æ–∫–µ–Ω PROM_API_TOKEN –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ!")
        return
    if not os.path.exists(FEEDS_FILE):
        print(f"‚ùå –§–∞–π–ª {FEEDS_FILE} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ!")
        return

    with open(FEEDS_FILE, "r", encoding="utf-8") as f:
        feed_urls = [line.strip() for line in f if line.strip()]

    old_state = load_previous_state()
    print(f"üìÇ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π —Å—Ç–∞–Ω: {len(old_state)} —Ç–æ–≤–∞—Ä—ñ–≤\n")

    print("üîÑ –ó–±—ñ—Ä –¥–∞–Ω–∏—Ö –∑ —Ñ—ñ–¥—ñ–≤...")
    all_products: List[Dict[str, Any]] = []
    failed_feeds: List[str] = []

    async with aiohttp.ClientSession() as session:
        tasks = [parse_feed(session, url, i + 1) for i, url in enumerate(feed_urls)]
        results = await asyncio.gather(*tasks)
        for url, (success, products) in zip(feed_urls, results):
            if success:
                print(f"‚úÖ {url}: {len(products)} —Ç–æ–≤–∞—Ä—ñ–≤")
                all_products.extend(products)
            else:
                failed_feeds.append(url)

        print("\nüìä –ü—ñ–¥—Å—É–º–æ–∫ –∑–±–æ—Ä—É:")
        print(f"‚úÖ –£—Å–ø—ñ—à–Ω–∏—Ö —Ñ—ñ–¥—ñ–≤: {len(feed_urls) - len(failed_feeds)}/{len(feed_urls)}")
        print(f"üì¶ –ó–∞–≥–∞–ª—å–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Ç–æ–≤–∞—Ä—ñ–≤: {len(all_products)}\n")

        if failed_feeds:
            print("‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç—É–ø–Ω—ñ —Ñ—ñ–¥–∏:")
            for u in failed_feeds:
                print(f"  - {u}")
            if REQUIRE_ALL_FEEDS:
                print("\nüõë –ó–£–ü–ò–ù–ö–ê: –ù–µ –≤—Å—ñ —Ñ—ñ–¥–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ! –û–Ω–æ–≤–ª–µ–Ω–Ω—è –Ω–µ –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è.")
                return

        if not all_products:
            print("‚ùå –ù–µ–º–∞—î —Ç–æ–≤–∞—Ä—ñ–≤!")
            return

        changed_products = [p for p in all_products if has_changed(p, old_state)]

        print("üîç –ê–Ω–∞–ª—ñ–∑ –∑–º—ñ–Ω:")
        print(f"üì¶ –í—Å—å–æ–≥–æ —Ç–æ–≤–∞—Ä—ñ–≤: {len(all_products)}")
        print(f"üîÑ –ó–º—ñ–Ω–∏–ª–æ—Å—å: {len(changed_products)}\n")

        if not changed_products:
            print("‚úÖ –ù–µ–º–∞—î –∑–º—ñ–Ω ‚Äî –Ω—ñ—á–æ–≥–æ –≤—ñ–¥–ø—Ä–∞–≤–ª—è—Ç–∏")
            save_current_state(all_products)
            return

        total_batches = (len(changed_products) - 1) // BATCH_SIZE + 1
        print(f"üöÄ –û–Ω–æ–≤–ª–µ–Ω–Ω—è {len(changed_products)} —Ç–æ–≤–∞—Ä—ñ–≤ —É {total_batches} –ø–∞—Ä—Ç—ñ—è—Ö...")

        start = time.time()
        async with aiohttp.ClientSession() as api_session:
            # –Ω–∞–¥—Å–∏–ª–∞—î–º–æ —Ö–≤–∏–ª—è–º–∏, –ø–æ CONCURRENT_REQUESTS –ø–∞—Ä—Ç—ñ–π –æ–¥–Ω–æ—á–∞—Å–Ω–æ
            for i in range(0, len(changed_products), BATCH_SIZE * CONCURRENT_REQUESTS):
                jobs = []
                for j in range(CONCURRENT_REQUESTS):
                    idx = i + j * BATCH_SIZE
                    if idx >= len(changed_products):
                        break
                    batch = changed_products[idx: idx + BATCH_SIZE]
                    batch_num = idx // BATCH_SIZE + 1
                    jobs.append(send_updates(api_session, batch, batch_num, total_batches))
                await asyncio.gather(*jobs)
                await asyncio.sleep(DELAY_BETWEEN_WAVES)

        duration = time.time() - start
        save_current_state(all_products)
        print(f"\nüíæ –°—Ç–∞–Ω –∑–±–µ—Ä–µ–∂–µ–Ω–æ: {len(all_products)} —Ç–æ–≤–∞—Ä—ñ–≤")
        print(f"‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ –∑–∞ {duration:.1f}—Å ({duration/60:.1f}—Ö–≤)")
        if changed_products:
            print(f"üìä –®–≤–∏–¥–∫—ñ—Å—Ç—å: {len(changed_products)/duration:.1f} —Ç–æ–≤–∞—Ä—ñ–≤/—Å–µ–∫")

def main() -> None:
    asyncio.run(main_async())

if __name__ == "__main__":
    main()
